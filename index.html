<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Plane Detection + Babylon.js + cannon-es (CDN)</title>
    <style>
        body { margin: 0; }
        #renderCanvas { width: 100%; height: 100%; display: block; }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <!-- Babylon.js, cannon-es, and their dependencies via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/babylonjs@5.0.0/babylon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-loaders@5.0.0/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-gui@5.0.0/babylon.gui.min.js"></script>
    
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        
        let scene;
        let xr;
        let physicsWorld;
        const planeColliders = new Map();
        const cannonBodies = new Map();
        const detectedMeshes = new Map();

        const createScene = async () => {
            scene = new BABYLON.Scene(engine);
            scene.gravity = new BABYLON.Vector3(0, -9.81, 0);

            // Initialize cannon-es physics plugin
            const physicsPlugin = new BABYLON.CannonJSPlugin(true, 10, CANNON);
            scene.enablePhysics(scene.gravity, physicsPlugin);
            physicsWorld = physicsPlugin.world;
            
            // Create a camera to be replaced by the XR camera
            const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 1.6, 0), scene);
            camera.setTarget(BABYLON.Vector3.Zero());
            
            // Add a light source
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            
            // Initialize WebXR with AR features
            xr = await scene.createDefaultXRExperienceAsync({
                uiOptions: { sessionMode: BABYLON.WebXRMode.AR },
                optionalFeatures: ["hit-test", "plane-detection"]
            });

            // Enable plane detection and register callbacks
            const planeDetector = xr.baseExperience.featuresManager.enableFeature(
                BABYLON.WebXRFeatureName.PLANE_DETECTION, "latest"
            );

            planeDetector.onPlaneAddedObservable.add(plane => {
                // Create Babylon mesh for visualization
                const planeMesh = BABYLON.Mesh.CreatePlane("plane", 1, scene);
                planeMesh.rotation.x = Math.PI / 2;
                planeMesh.material = new BABYLON.StandardMaterial("planeMat", scene);
                planeMesh.material.alpha = 0.5;
                detectedMeshes.set(plane.id, planeMesh);

                // Create cannon-es static body
                const cannonBody = new CANNON.Body({
                    mass: 0, // static body
                    shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.01, 0.5)),
                    position: new CANNON.Vec3(planeMesh.position.x, planeMesh.position.y, planeMesh.position.z),
                    quaternion: new CANNON.Quaternion(planeMesh.rotationQuaternion.x, planeMesh.rotationQuaternion.y, planeMesh.rotationQuaternion.z, planeMesh.rotationQuaternion.w)
                });
                physicsWorld.addBody(cannonBody);
                planeColliders.set(plane.id, cannonBody);
            });

            planeDetector.onPlaneUpdatedObservable.add(plane => {
                // Update Babylon mesh pose and size
                const planeMesh = detectedMeshes.get(plane.id);
                if (planeMesh) {
                    planeMesh.position = plane.position;
                    planeMesh.rotationQuaternion = plane.rotationQuaternion;
                    planeMesh.scaling = new BABYLON.Vector3(plane.width, plane.height, 1);
                }
                
                // Update cannon-es body (more complex for polygons, but simple for a cuboid)
                const cannonBody = planeColliders.get(plane.id);
                if (cannonBody) {
                    cannonBody.position = new CANNON.Vec3(plane.position.x, plane.position.y, plane.position.z);
                    cannonBody.quaternion = new CANNON.Quaternion(plane.rotationQuaternion.x, plane.rotationQuaternion.y, plane.rotationQuaternion.z, plane.rotationQuaternion.w);
                    // For a more accurate shape, you would replace the old body with a new one
                    // that uses a ConvexPolyhedron or heightfield, derived from the polygon points.
                }
            });

            planeDetector.onPlaneRemovedObservable.add(plane => {
                const planeMesh = detectedMeshes.get(plane.id);
                if (planeMesh) {
                    planeMesh.dispose();
                    detectedMeshes.delete(plane.id);
                }
                const cannonBody = planeColliders.get(plane.id);
                if (cannonBody) {
                    physicsWorld.removeBody(cannonBody);
                    planeColliders.delete(plane.id);
                }
            });

            // Create a dynamic cube for physics simulation
            const cubeSize = 0.2;
            const cubeMesh = BABYLON.MeshBuilder.CreateBox("cube", { size: cubeSize }, scene);
            cubeMesh.material = new BABYLON.StandardMaterial("cubeMat", scene);
            cubeMesh.material.diffuseColor = BABYLON.Color3.Teal();
            cubeMesh.position = new BABYLON.Vector3(0, 1.5, -2);
            
            const cubeShape = new CANNON.Box(new CANNON.Vec3(cubeSize / 2, cubeSize / 2, cubeSize / 2));
            const cubeBody = new CANNON.Body({
                mass: 1,
                shape: cubeShape,
                position: new CANNON.Vec3(0, 1.5, -2)
            });
            physicsWorld.addBody(cubeBody);
            cannonBodies.set('falling-cube', { body: cubeBody, mesh: cubeMesh });
            
            return scene;
        };

        createScene().then(scene => {
            engine.runRenderLoop(() => {
                // Sync physics body positions with Babylon meshes
                for (const { body, mesh } of cannonBodies.values()) {
                    mesh.position.copyFrom(body.position);
                    mesh.rotationQuaternion.copyFrom(body.quaternion);
                }
                
                // Render the scene
                if (scene) {
                    scene.render();
                }
            });
        });

        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>
